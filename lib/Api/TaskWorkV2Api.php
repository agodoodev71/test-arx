<?php
/**
 * TaskWorkV2Api
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Abletech.Arxivar.Server.WebApi.Services
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.3.1
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * TaskWorkV2Api Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class TaskWorkV2Api
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation taskWorkV2ActivateTaskwork
     *
     * This call returns a taskwork if active
     *
     * @param  int $task_work_id Taskwork identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TaskWorkDTO
     */
    public function taskWorkV2ActivateTaskwork($task_work_id)
    {
        list($response) = $this->taskWorkV2ActivateTaskworkWithHttpInfo($task_work_id);
        return $response;
    }

    /**
     * Operation taskWorkV2ActivateTaskworkWithHttpInfo
     *
     * This call returns a taskwork if active
     *
     * @param  int $task_work_id Taskwork identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TaskWorkDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskWorkV2ActivateTaskworkWithHttpInfo($task_work_id)
    {
        $returnType = '\Swagger\Client\Model\TaskWorkDTO';
        $request = $this->taskWorkV2ActivateTaskworkRequest($task_work_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TaskWorkDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskWorkV2ActivateTaskworkAsync
     *
     * This call returns a taskwork if active
     *
     * @param  int $task_work_id Taskwork identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2ActivateTaskworkAsync($task_work_id)
    {
        return $this->taskWorkV2ActivateTaskworkAsyncWithHttpInfo($task_work_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskWorkV2ActivateTaskworkAsyncWithHttpInfo
     *
     * This call returns a taskwork if active
     *
     * @param  int $task_work_id Taskwork identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2ActivateTaskworkAsyncWithHttpInfo($task_work_id)
    {
        $returnType = '\Swagger\Client\Model\TaskWorkDTO';
        $request = $this->taskWorkV2ActivateTaskworkRequest($task_work_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskWorkV2ActivateTaskwork'
     *
     * @param  int $task_work_id Taskwork identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskWorkV2ActivateTaskworkRequest($task_work_id)
    {
        // verify the required parameter 'task_work_id' is set
        if ($task_work_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_work_id when calling taskWorkV2ActivateTaskwork'
            );
        }

        $resourcePath = '/api/v2/TaskWork/{taskWorkId}/Activate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_work_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskWorkId' . '}',
                ObjectSerializer::toPathValue($task_work_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskWorkV2AutoAssign
     *
     * This call autoassigns the taskwork
     *
     * @param  int $taskwork_id Taskwork identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function taskWorkV2AutoAssign($taskwork_id)
    {
        $this->taskWorkV2AutoAssignWithHttpInfo($taskwork_id);
    }

    /**
     * Operation taskWorkV2AutoAssignWithHttpInfo
     *
     * This call autoassigns the taskwork
     *
     * @param  int $taskwork_id Taskwork identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskWorkV2AutoAssignWithHttpInfo($taskwork_id)
    {
        $returnType = '';
        $request = $this->taskWorkV2AutoAssignRequest($taskwork_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation taskWorkV2AutoAssignAsync
     *
     * This call autoassigns the taskwork
     *
     * @param  int $taskwork_id Taskwork identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2AutoAssignAsync($taskwork_id)
    {
        return $this->taskWorkV2AutoAssignAsyncWithHttpInfo($taskwork_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskWorkV2AutoAssignAsyncWithHttpInfo
     *
     * This call autoassigns the taskwork
     *
     * @param  int $taskwork_id Taskwork identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2AutoAssignAsyncWithHttpInfo($taskwork_id)
    {
        $returnType = '';
        $request = $this->taskWorkV2AutoAssignRequest($taskwork_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskWorkV2AutoAssign'
     *
     * @param  int $taskwork_id Taskwork identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskWorkV2AutoAssignRequest($taskwork_id)
    {
        // verify the required parameter 'taskwork_id' is set
        if ($taskwork_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $taskwork_id when calling taskWorkV2AutoAssign'
            );
        }

        $resourcePath = '/api/v2/TaskWork/autoassign/{taskworkId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($taskwork_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskworkId' . '}',
                ObjectSerializer::toPathValue($taskwork_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskWorkV2CanFinalizeTaskByIds
     *
     * This call returns if is possible to close task work list
     *
     * @param  int[] $taskworkids List of taskwork identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CloseEligibleResult[]
     */
    public function taskWorkV2CanFinalizeTaskByIds($taskworkids)
    {
        list($response) = $this->taskWorkV2CanFinalizeTaskByIdsWithHttpInfo($taskworkids);
        return $response;
    }

    /**
     * Operation taskWorkV2CanFinalizeTaskByIdsWithHttpInfo
     *
     * This call returns if is possible to close task work list
     *
     * @param  int[] $taskworkids List of taskwork identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CloseEligibleResult[], HTTP status code, HTTP response headers (array of strings)
     */
    public function taskWorkV2CanFinalizeTaskByIdsWithHttpInfo($taskworkids)
    {
        $returnType = '\Swagger\Client\Model\CloseEligibleResult[]';
        $request = $this->taskWorkV2CanFinalizeTaskByIdsRequest($taskworkids);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\CloseEligibleResult[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskWorkV2CanFinalizeTaskByIdsAsync
     *
     * This call returns if is possible to close task work list
     *
     * @param  int[] $taskworkids List of taskwork identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2CanFinalizeTaskByIdsAsync($taskworkids)
    {
        return $this->taskWorkV2CanFinalizeTaskByIdsAsyncWithHttpInfo($taskworkids)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskWorkV2CanFinalizeTaskByIdsAsyncWithHttpInfo
     *
     * This call returns if is possible to close task work list
     *
     * @param  int[] $taskworkids List of taskwork identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2CanFinalizeTaskByIdsAsyncWithHttpInfo($taskworkids)
    {
        $returnType = '\Swagger\Client\Model\CloseEligibleResult[]';
        $request = $this->taskWorkV2CanFinalizeTaskByIdsRequest($taskworkids);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskWorkV2CanFinalizeTaskByIds'
     *
     * @param  int[] $taskworkids List of taskwork identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskWorkV2CanFinalizeTaskByIdsRequest($taskworkids)
    {
        // verify the required parameter 'taskworkids' is set
        if ($taskworkids === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $taskworkids when calling taskWorkV2CanFinalizeTaskByIds'
            );
        }

        $resourcePath = '/api/v2/TaskWork/canfinalize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($taskworkids)) {
            $_tempBody = $taskworkids;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskWorkV2CanFinalizeTaskByIdsAndExitCodeAndPassword
     *
     * This call returns if is possible to close task work list by exit code and password
     *
     * @param  \Swagger\Client\Model\TaskWorkCloseRequest $close_request Taskwork information (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CloseEligibleResult[]
     */
    public function taskWorkV2CanFinalizeTaskByIdsAndExitCodeAndPassword($close_request)
    {
        list($response) = $this->taskWorkV2CanFinalizeTaskByIdsAndExitCodeAndPasswordWithHttpInfo($close_request);
        return $response;
    }

    /**
     * Operation taskWorkV2CanFinalizeTaskByIdsAndExitCodeAndPasswordWithHttpInfo
     *
     * This call returns if is possible to close task work list by exit code and password
     *
     * @param  \Swagger\Client\Model\TaskWorkCloseRequest $close_request Taskwork information (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CloseEligibleResult[], HTTP status code, HTTP response headers (array of strings)
     */
    public function taskWorkV2CanFinalizeTaskByIdsAndExitCodeAndPasswordWithHttpInfo($close_request)
    {
        $returnType = '\Swagger\Client\Model\CloseEligibleResult[]';
        $request = $this->taskWorkV2CanFinalizeTaskByIdsAndExitCodeAndPasswordRequest($close_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\CloseEligibleResult[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskWorkV2CanFinalizeTaskByIdsAndExitCodeAndPasswordAsync
     *
     * This call returns if is possible to close task work list by exit code and password
     *
     * @param  \Swagger\Client\Model\TaskWorkCloseRequest $close_request Taskwork information (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2CanFinalizeTaskByIdsAndExitCodeAndPasswordAsync($close_request)
    {
        return $this->taskWorkV2CanFinalizeTaskByIdsAndExitCodeAndPasswordAsyncWithHttpInfo($close_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskWorkV2CanFinalizeTaskByIdsAndExitCodeAndPasswordAsyncWithHttpInfo
     *
     * This call returns if is possible to close task work list by exit code and password
     *
     * @param  \Swagger\Client\Model\TaskWorkCloseRequest $close_request Taskwork information (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2CanFinalizeTaskByIdsAndExitCodeAndPasswordAsyncWithHttpInfo($close_request)
    {
        $returnType = '\Swagger\Client\Model\CloseEligibleResult[]';
        $request = $this->taskWorkV2CanFinalizeTaskByIdsAndExitCodeAndPasswordRequest($close_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskWorkV2CanFinalizeTaskByIdsAndExitCodeAndPassword'
     *
     * @param  \Swagger\Client\Model\TaskWorkCloseRequest $close_request Taskwork information (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskWorkV2CanFinalizeTaskByIdsAndExitCodeAndPasswordRequest($close_request)
    {
        // verify the required parameter 'close_request' is set
        if ($close_request === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $close_request when calling taskWorkV2CanFinalizeTaskByIdsAndExitCodeAndPassword'
            );
        }

        $resourcePath = '/api/v2/TaskWork/canfinalizebyexitcodeandpassword';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($close_request)) {
            $_tempBody = $close_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskWorkV2DeleteTaskWorkById
     *
     * This call deletes the task
     *
     * @param  int $task_work_id Taskwork identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function taskWorkV2DeleteTaskWorkById($task_work_id)
    {
        $this->taskWorkV2DeleteTaskWorkByIdWithHttpInfo($task_work_id);
    }

    /**
     * Operation taskWorkV2DeleteTaskWorkByIdWithHttpInfo
     *
     * This call deletes the task
     *
     * @param  int $task_work_id Taskwork identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskWorkV2DeleteTaskWorkByIdWithHttpInfo($task_work_id)
    {
        $returnType = '';
        $request = $this->taskWorkV2DeleteTaskWorkByIdRequest($task_work_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation taskWorkV2DeleteTaskWorkByIdAsync
     *
     * This call deletes the task
     *
     * @param  int $task_work_id Taskwork identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2DeleteTaskWorkByIdAsync($task_work_id)
    {
        return $this->taskWorkV2DeleteTaskWorkByIdAsyncWithHttpInfo($task_work_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskWorkV2DeleteTaskWorkByIdAsyncWithHttpInfo
     *
     * This call deletes the task
     *
     * @param  int $task_work_id Taskwork identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2DeleteTaskWorkByIdAsyncWithHttpInfo($task_work_id)
    {
        $returnType = '';
        $request = $this->taskWorkV2DeleteTaskWorkByIdRequest($task_work_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskWorkV2DeleteTaskWorkById'
     *
     * @param  int $task_work_id Taskwork identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskWorkV2DeleteTaskWorkByIdRequest($task_work_id)
    {
        // verify the required parameter 'task_work_id' is set
        if ($task_work_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_work_id when calling taskWorkV2DeleteTaskWorkById'
            );
        }

        $resourcePath = '/api/v2/TaskWork/{taskWorkId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_work_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskWorkId' . '}',
                ObjectSerializer::toPathValue($task_work_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskWorkV2FinalizeTaskByIdsAndExitCodeAndPassword
     *
     * This call closes a task work list
     *
     * @param  \Swagger\Client\Model\TaskWorkCloseRequest $close_request Taskwork information (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function taskWorkV2FinalizeTaskByIdsAndExitCodeAndPassword($close_request)
    {
        $this->taskWorkV2FinalizeTaskByIdsAndExitCodeAndPasswordWithHttpInfo($close_request);
    }

    /**
     * Operation taskWorkV2FinalizeTaskByIdsAndExitCodeAndPasswordWithHttpInfo
     *
     * This call closes a task work list
     *
     * @param  \Swagger\Client\Model\TaskWorkCloseRequest $close_request Taskwork information (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskWorkV2FinalizeTaskByIdsAndExitCodeAndPasswordWithHttpInfo($close_request)
    {
        $returnType = '';
        $request = $this->taskWorkV2FinalizeTaskByIdsAndExitCodeAndPasswordRequest($close_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation taskWorkV2FinalizeTaskByIdsAndExitCodeAndPasswordAsync
     *
     * This call closes a task work list
     *
     * @param  \Swagger\Client\Model\TaskWorkCloseRequest $close_request Taskwork information (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2FinalizeTaskByIdsAndExitCodeAndPasswordAsync($close_request)
    {
        return $this->taskWorkV2FinalizeTaskByIdsAndExitCodeAndPasswordAsyncWithHttpInfo($close_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskWorkV2FinalizeTaskByIdsAndExitCodeAndPasswordAsyncWithHttpInfo
     *
     * This call closes a task work list
     *
     * @param  \Swagger\Client\Model\TaskWorkCloseRequest $close_request Taskwork information (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2FinalizeTaskByIdsAndExitCodeAndPasswordAsyncWithHttpInfo($close_request)
    {
        $returnType = '';
        $request = $this->taskWorkV2FinalizeTaskByIdsAndExitCodeAndPasswordRequest($close_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskWorkV2FinalizeTaskByIdsAndExitCodeAndPassword'
     *
     * @param  \Swagger\Client\Model\TaskWorkCloseRequest $close_request Taskwork information (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskWorkV2FinalizeTaskByIdsAndExitCodeAndPasswordRequest($close_request)
    {
        // verify the required parameter 'close_request' is set
        if ($close_request === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $close_request when calling taskWorkV2FinalizeTaskByIdsAndExitCodeAndPassword'
            );
        }

        $resourcePath = '/api/v2/TaskWork/finalize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($close_request)) {
            $_tempBody = $close_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskWorkV2GetActiveTaskWork
     *
     * This call executes a task search and return taskwork active for the user on a specific document.  This call could not be compatible with some programming language, in this case use the call api/TaskWork/actives/{docnumber}
     *
     * @param  \Swagger\Client\Model\SelectDTO $select Selection Fields (required)
     * @param  int $docnumber Document Identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function taskWorkV2GetActiveTaskWork($select, $docnumber)
    {
        list($response) = $this->taskWorkV2GetActiveTaskWorkWithHttpInfo($select, $docnumber);
        return $response;
    }

    /**
     * Operation taskWorkV2GetActiveTaskWorkWithHttpInfo
     *
     * This call executes a task search and return taskwork active for the user on a specific document.  This call could not be compatible with some programming language, in this case use the call api/TaskWork/actives/{docnumber}
     *
     * @param  \Swagger\Client\Model\SelectDTO $select Selection Fields (required)
     * @param  int $docnumber Document Identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskWorkV2GetActiveTaskWorkWithHttpInfo($select, $docnumber)
    {
        $returnType = 'object';
        $request = $this->taskWorkV2GetActiveTaskWorkRequest($select, $docnumber);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskWorkV2GetActiveTaskWorkAsync
     *
     * This call executes a task search and return taskwork active for the user on a specific document.  This call could not be compatible with some programming language, in this case use the call api/TaskWork/actives/{docnumber}
     *
     * @param  \Swagger\Client\Model\SelectDTO $select Selection Fields (required)
     * @param  int $docnumber Document Identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2GetActiveTaskWorkAsync($select, $docnumber)
    {
        return $this->taskWorkV2GetActiveTaskWorkAsyncWithHttpInfo($select, $docnumber)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskWorkV2GetActiveTaskWorkAsyncWithHttpInfo
     *
     * This call executes a task search and return taskwork active for the user on a specific document.  This call could not be compatible with some programming language, in this case use the call api/TaskWork/actives/{docnumber}
     *
     * @param  \Swagger\Client\Model\SelectDTO $select Selection Fields (required)
     * @param  int $docnumber Document Identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2GetActiveTaskWorkAsyncWithHttpInfo($select, $docnumber)
    {
        $returnType = 'object';
        $request = $this->taskWorkV2GetActiveTaskWorkRequest($select, $docnumber);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskWorkV2GetActiveTaskWork'
     *
     * @param  \Swagger\Client\Model\SelectDTO $select Selection Fields (required)
     * @param  int $docnumber Document Identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskWorkV2GetActiveTaskWorkRequest($select, $docnumber)
    {
        // verify the required parameter 'select' is set
        if ($select === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $select when calling taskWorkV2GetActiveTaskWork'
            );
        }
        // verify the required parameter 'docnumber' is set
        if ($docnumber === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $docnumber when calling taskWorkV2GetActiveTaskWork'
            );
        }

        $resourcePath = '/api/v2/TaskWork/actives/{docnumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($docnumber !== null) {
            $resourcePath = str_replace(
                '{' . 'docnumber' . '}',
                ObjectSerializer::toPathValue($docnumber),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($select)) {
            $_tempBody = $select;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskWorkV2GetDefaultSelect
     *
     * This call provides default select for tasklist search
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\SelectDTO
     */
    public function taskWorkV2GetDefaultSelect()
    {
        list($response) = $this->taskWorkV2GetDefaultSelectWithHttpInfo();
        return $response;
    }

    /**
     * Operation taskWorkV2GetDefaultSelectWithHttpInfo
     *
     * This call provides default select for tasklist search
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\SelectDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskWorkV2GetDefaultSelectWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\SelectDTO';
        $request = $this->taskWorkV2GetDefaultSelectRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\SelectDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskWorkV2GetDefaultSelectAsync
     *
     * This call provides default select for tasklist search
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2GetDefaultSelectAsync()
    {
        return $this->taskWorkV2GetDefaultSelectAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskWorkV2GetDefaultSelectAsyncWithHttpInfo
     *
     * This call provides default select for tasklist search
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2GetDefaultSelectAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\SelectDTO';
        $request = $this->taskWorkV2GetDefaultSelectRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskWorkV2GetDefaultSelect'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskWorkV2GetDefaultSelectRequest()
    {

        $resourcePath = '/api/v2/TaskWork/defaultselect';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskWorkV2GetDocumentsByProcessId
     *
     * This call returns the task documents.  This call could not be compatible with some programming language, in this case use the call api/TaskWork/documents/{processId}
     *
     * @param  int $process_id Process identifier (required)
     * @param  \Swagger\Client\Model\SelectDTO $select Field select configuration (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function taskWorkV2GetDocumentsByProcessId($process_id, $select)
    {
        list($response) = $this->taskWorkV2GetDocumentsByProcessIdWithHttpInfo($process_id, $select);
        return $response;
    }

    /**
     * Operation taskWorkV2GetDocumentsByProcessIdWithHttpInfo
     *
     * This call returns the task documents.  This call could not be compatible with some programming language, in this case use the call api/TaskWork/documents/{processId}
     *
     * @param  int $process_id Process identifier (required)
     * @param  \Swagger\Client\Model\SelectDTO $select Field select configuration (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskWorkV2GetDocumentsByProcessIdWithHttpInfo($process_id, $select)
    {
        $returnType = 'object';
        $request = $this->taskWorkV2GetDocumentsByProcessIdRequest($process_id, $select);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskWorkV2GetDocumentsByProcessIdAsync
     *
     * This call returns the task documents.  This call could not be compatible with some programming language, in this case use the call api/TaskWork/documents/{processId}
     *
     * @param  int $process_id Process identifier (required)
     * @param  \Swagger\Client\Model\SelectDTO $select Field select configuration (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2GetDocumentsByProcessIdAsync($process_id, $select)
    {
        return $this->taskWorkV2GetDocumentsByProcessIdAsyncWithHttpInfo($process_id, $select)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskWorkV2GetDocumentsByProcessIdAsyncWithHttpInfo
     *
     * This call returns the task documents.  This call could not be compatible with some programming language, in this case use the call api/TaskWork/documents/{processId}
     *
     * @param  int $process_id Process identifier (required)
     * @param  \Swagger\Client\Model\SelectDTO $select Field select configuration (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2GetDocumentsByProcessIdAsyncWithHttpInfo($process_id, $select)
    {
        $returnType = 'object';
        $request = $this->taskWorkV2GetDocumentsByProcessIdRequest($process_id, $select);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskWorkV2GetDocumentsByProcessId'
     *
     * @param  int $process_id Process identifier (required)
     * @param  \Swagger\Client\Model\SelectDTO $select Field select configuration (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskWorkV2GetDocumentsByProcessIdRequest($process_id, $select)
    {
        // verify the required parameter 'process_id' is set
        if ($process_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $process_id when calling taskWorkV2GetDocumentsByProcessId'
            );
        }
        // verify the required parameter 'select' is set
        if ($select === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $select when calling taskWorkV2GetDocumentsByProcessId'
            );
        }

        $resourcePath = '/api/v2/TaskWork/documents/{processId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($process_id !== null) {
            $resourcePath = str_replace(
                '{' . 'processId' . '}',
                ObjectSerializer::toPathValue($process_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($select)) {
            $_tempBody = $select;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskWorkV2GetDocumentsFilenameByProcessId
     *
     * @param  int $process_id process_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\KeyValueElementDto[]
     */
    public function taskWorkV2GetDocumentsFilenameByProcessId($process_id)
    {
        list($response) = $this->taskWorkV2GetDocumentsFilenameByProcessIdWithHttpInfo($process_id);
        return $response;
    }

    /**
     * Operation taskWorkV2GetDocumentsFilenameByProcessIdWithHttpInfo
     *
     * @param  int $process_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\KeyValueElementDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function taskWorkV2GetDocumentsFilenameByProcessIdWithHttpInfo($process_id)
    {
        $returnType = '\Swagger\Client\Model\KeyValueElementDto[]';
        $request = $this->taskWorkV2GetDocumentsFilenameByProcessIdRequest($process_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\KeyValueElementDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskWorkV2GetDocumentsFilenameByProcessIdAsync
     *
     * 
     *
     * @param  int $process_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2GetDocumentsFilenameByProcessIdAsync($process_id)
    {
        return $this->taskWorkV2GetDocumentsFilenameByProcessIdAsyncWithHttpInfo($process_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskWorkV2GetDocumentsFilenameByProcessIdAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $process_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2GetDocumentsFilenameByProcessIdAsyncWithHttpInfo($process_id)
    {
        $returnType = '\Swagger\Client\Model\KeyValueElementDto[]';
        $request = $this->taskWorkV2GetDocumentsFilenameByProcessIdRequest($process_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskWorkV2GetDocumentsFilenameByProcessId'
     *
     * @param  int $process_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskWorkV2GetDocumentsFilenameByProcessIdRequest($process_id)
    {
        // verify the required parameter 'process_id' is set
        if ($process_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $process_id when calling taskWorkV2GetDocumentsFilenameByProcessId'
            );
        }

        $resourcePath = '/api/v2/TaskWork/documents/filenames/{processId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($process_id !== null) {
            $resourcePath = str_replace(
                '{' . 'processId' . '}',
                ObjectSerializer::toPathValue($process_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskWorkV2GetExitCodesByTaskWorkIds
     *
     * This call returns all possible exit code for taskWorks list
     *
     * @param  int[] $task_work_ids List of taskwork identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TaskExitCodeDTO[]
     */
    public function taskWorkV2GetExitCodesByTaskWorkIds($task_work_ids)
    {
        list($response) = $this->taskWorkV2GetExitCodesByTaskWorkIdsWithHttpInfo($task_work_ids);
        return $response;
    }

    /**
     * Operation taskWorkV2GetExitCodesByTaskWorkIdsWithHttpInfo
     *
     * This call returns all possible exit code for taskWorks list
     *
     * @param  int[] $task_work_ids List of taskwork identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TaskExitCodeDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function taskWorkV2GetExitCodesByTaskWorkIdsWithHttpInfo($task_work_ids)
    {
        $returnType = '\Swagger\Client\Model\TaskExitCodeDTO[]';
        $request = $this->taskWorkV2GetExitCodesByTaskWorkIdsRequest($task_work_ids);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TaskExitCodeDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskWorkV2GetExitCodesByTaskWorkIdsAsync
     *
     * This call returns all possible exit code for taskWorks list
     *
     * @param  int[] $task_work_ids List of taskwork identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2GetExitCodesByTaskWorkIdsAsync($task_work_ids)
    {
        return $this->taskWorkV2GetExitCodesByTaskWorkIdsAsyncWithHttpInfo($task_work_ids)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskWorkV2GetExitCodesByTaskWorkIdsAsyncWithHttpInfo
     *
     * This call returns all possible exit code for taskWorks list
     *
     * @param  int[] $task_work_ids List of taskwork identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2GetExitCodesByTaskWorkIdsAsyncWithHttpInfo($task_work_ids)
    {
        $returnType = '\Swagger\Client\Model\TaskExitCodeDTO[]';
        $request = $this->taskWorkV2GetExitCodesByTaskWorkIdsRequest($task_work_ids);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskWorkV2GetExitCodesByTaskWorkIds'
     *
     * @param  int[] $task_work_ids List of taskwork identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskWorkV2GetExitCodesByTaskWorkIdsRequest($task_work_ids)
    {
        // verify the required parameter 'task_work_ids' is set
        if ($task_work_ids === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_work_ids when calling taskWorkV2GetExitCodesByTaskWorkIds'
            );
        }

        $resourcePath = '/api/v2/TaskWork/exitcodes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($task_work_ids)) {
            $_tempBody = $task_work_ids;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskWorkV2GetProfileSchemaForTaskWorkMaskDocumentOperation
     *
     * This call returns a document schema for a mask insert document taskWork operation
     *
     * @param  int $task_work_id Taskwork identifier (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\MaskProfileSchemaDTO
     */
    public function taskWorkV2GetProfileSchemaForTaskWorkMaskDocumentOperation($task_work_id, $task_work_document_operation_id)
    {
        list($response) = $this->taskWorkV2GetProfileSchemaForTaskWorkMaskDocumentOperationWithHttpInfo($task_work_id, $task_work_document_operation_id);
        return $response;
    }

    /**
     * Operation taskWorkV2GetProfileSchemaForTaskWorkMaskDocumentOperationWithHttpInfo
     *
     * This call returns a document schema for a mask insert document taskWork operation
     *
     * @param  int $task_work_id Taskwork identifier (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\MaskProfileSchemaDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskWorkV2GetProfileSchemaForTaskWorkMaskDocumentOperationWithHttpInfo($task_work_id, $task_work_document_operation_id)
    {
        $returnType = '\Swagger\Client\Model\MaskProfileSchemaDTO';
        $request = $this->taskWorkV2GetProfileSchemaForTaskWorkMaskDocumentOperationRequest($task_work_id, $task_work_document_operation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\MaskProfileSchemaDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskWorkV2GetProfileSchemaForTaskWorkMaskDocumentOperationAsync
     *
     * This call returns a document schema for a mask insert document taskWork operation
     *
     * @param  int $task_work_id Taskwork identifier (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2GetProfileSchemaForTaskWorkMaskDocumentOperationAsync($task_work_id, $task_work_document_operation_id)
    {
        return $this->taskWorkV2GetProfileSchemaForTaskWorkMaskDocumentOperationAsyncWithHttpInfo($task_work_id, $task_work_document_operation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskWorkV2GetProfileSchemaForTaskWorkMaskDocumentOperationAsyncWithHttpInfo
     *
     * This call returns a document schema for a mask insert document taskWork operation
     *
     * @param  int $task_work_id Taskwork identifier (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2GetProfileSchemaForTaskWorkMaskDocumentOperationAsyncWithHttpInfo($task_work_id, $task_work_document_operation_id)
    {
        $returnType = '\Swagger\Client\Model\MaskProfileSchemaDTO';
        $request = $this->taskWorkV2GetProfileSchemaForTaskWorkMaskDocumentOperationRequest($task_work_id, $task_work_document_operation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskWorkV2GetProfileSchemaForTaskWorkMaskDocumentOperation'
     *
     * @param  int $task_work_id Taskwork identifier (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskWorkV2GetProfileSchemaForTaskWorkMaskDocumentOperationRequest($task_work_id, $task_work_document_operation_id)
    {
        // verify the required parameter 'task_work_id' is set
        if ($task_work_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_work_id when calling taskWorkV2GetProfileSchemaForTaskWorkMaskDocumentOperation'
            );
        }
        // verify the required parameter 'task_work_document_operation_id' is set
        if ($task_work_document_operation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_work_document_operation_id when calling taskWorkV2GetProfileSchemaForTaskWorkMaskDocumentOperation'
            );
        }

        $resourcePath = '/api/v2/TaskWork/{taskWorkId}/documentsoperations/{taskWorkDocumentOperationId}/maskprofileSchema';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_work_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskWorkId' . '}',
                ObjectSerializer::toPathValue($task_work_id),
                $resourcePath
            );
        }
        // path params
        if ($task_work_document_operation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskWorkDocumentOperationId' . '}',
                ObjectSerializer::toPathValue($task_work_document_operation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskWorkV2GetProfileSchemaForTaskWorkModelDocumentOperation
     *
     * This call returns a profile schema for a model insert document taskWork operation
     *
     * @param  int $task_work_id Taskwork identifier (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ModelProfileSchemaDTO
     */
    public function taskWorkV2GetProfileSchemaForTaskWorkModelDocumentOperation($task_work_id, $task_work_document_operation_id)
    {
        list($response) = $this->taskWorkV2GetProfileSchemaForTaskWorkModelDocumentOperationWithHttpInfo($task_work_id, $task_work_document_operation_id);
        return $response;
    }

    /**
     * Operation taskWorkV2GetProfileSchemaForTaskWorkModelDocumentOperationWithHttpInfo
     *
     * This call returns a profile schema for a model insert document taskWork operation
     *
     * @param  int $task_work_id Taskwork identifier (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ModelProfileSchemaDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskWorkV2GetProfileSchemaForTaskWorkModelDocumentOperationWithHttpInfo($task_work_id, $task_work_document_operation_id)
    {
        $returnType = '\Swagger\Client\Model\ModelProfileSchemaDTO';
        $request = $this->taskWorkV2GetProfileSchemaForTaskWorkModelDocumentOperationRequest($task_work_id, $task_work_document_operation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ModelProfileSchemaDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskWorkV2GetProfileSchemaForTaskWorkModelDocumentOperationAsync
     *
     * This call returns a profile schema for a model insert document taskWork operation
     *
     * @param  int $task_work_id Taskwork identifier (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2GetProfileSchemaForTaskWorkModelDocumentOperationAsync($task_work_id, $task_work_document_operation_id)
    {
        return $this->taskWorkV2GetProfileSchemaForTaskWorkModelDocumentOperationAsyncWithHttpInfo($task_work_id, $task_work_document_operation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskWorkV2GetProfileSchemaForTaskWorkModelDocumentOperationAsyncWithHttpInfo
     *
     * This call returns a profile schema for a model insert document taskWork operation
     *
     * @param  int $task_work_id Taskwork identifier (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2GetProfileSchemaForTaskWorkModelDocumentOperationAsyncWithHttpInfo($task_work_id, $task_work_document_operation_id)
    {
        $returnType = '\Swagger\Client\Model\ModelProfileSchemaDTO';
        $request = $this->taskWorkV2GetProfileSchemaForTaskWorkModelDocumentOperationRequest($task_work_id, $task_work_document_operation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskWorkV2GetProfileSchemaForTaskWorkModelDocumentOperation'
     *
     * @param  int $task_work_id Taskwork identifier (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskWorkV2GetProfileSchemaForTaskWorkModelDocumentOperationRequest($task_work_id, $task_work_document_operation_id)
    {
        // verify the required parameter 'task_work_id' is set
        if ($task_work_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_work_id when calling taskWorkV2GetProfileSchemaForTaskWorkModelDocumentOperation'
            );
        }
        // verify the required parameter 'task_work_document_operation_id' is set
        if ($task_work_document_operation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_work_document_operation_id when calling taskWorkV2GetProfileSchemaForTaskWorkModelDocumentOperation'
            );
        }

        $resourcePath = '/api/v2/TaskWork/{taskWorkId}/documentsoperations/{taskWorkDocumentOperationId}/modelprofileSchema';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_work_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskWorkId' . '}',
                ObjectSerializer::toPathValue($task_work_id),
                $resourcePath
            );
        }
        // path params
        if ($task_work_document_operation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskWorkDocumentOperationId' . '}',
                ObjectSerializer::toPathValue($task_work_document_operation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskWorkV2GetProfileSchemaForTaskWorkStandardDocumentOperation
     *
     * This call returns a profile schema for a standard insert document taskWork operation
     *
     * @param  int $task_work_id Taskwork identifier (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\MaskProfileSchemaDTO
     */
    public function taskWorkV2GetProfileSchemaForTaskWorkStandardDocumentOperation($task_work_id, $task_work_document_operation_id)
    {
        list($response) = $this->taskWorkV2GetProfileSchemaForTaskWorkStandardDocumentOperationWithHttpInfo($task_work_id, $task_work_document_operation_id);
        return $response;
    }

    /**
     * Operation taskWorkV2GetProfileSchemaForTaskWorkStandardDocumentOperationWithHttpInfo
     *
     * This call returns a profile schema for a standard insert document taskWork operation
     *
     * @param  int $task_work_id Taskwork identifier (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\MaskProfileSchemaDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskWorkV2GetProfileSchemaForTaskWorkStandardDocumentOperationWithHttpInfo($task_work_id, $task_work_document_operation_id)
    {
        $returnType = '\Swagger\Client\Model\MaskProfileSchemaDTO';
        $request = $this->taskWorkV2GetProfileSchemaForTaskWorkStandardDocumentOperationRequest($task_work_id, $task_work_document_operation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\MaskProfileSchemaDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskWorkV2GetProfileSchemaForTaskWorkStandardDocumentOperationAsync
     *
     * This call returns a profile schema for a standard insert document taskWork operation
     *
     * @param  int $task_work_id Taskwork identifier (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2GetProfileSchemaForTaskWorkStandardDocumentOperationAsync($task_work_id, $task_work_document_operation_id)
    {
        return $this->taskWorkV2GetProfileSchemaForTaskWorkStandardDocumentOperationAsyncWithHttpInfo($task_work_id, $task_work_document_operation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskWorkV2GetProfileSchemaForTaskWorkStandardDocumentOperationAsyncWithHttpInfo
     *
     * This call returns a profile schema for a standard insert document taskWork operation
     *
     * @param  int $task_work_id Taskwork identifier (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2GetProfileSchemaForTaskWorkStandardDocumentOperationAsyncWithHttpInfo($task_work_id, $task_work_document_operation_id)
    {
        $returnType = '\Swagger\Client\Model\MaskProfileSchemaDTO';
        $request = $this->taskWorkV2GetProfileSchemaForTaskWorkStandardDocumentOperationRequest($task_work_id, $task_work_document_operation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskWorkV2GetProfileSchemaForTaskWorkStandardDocumentOperation'
     *
     * @param  int $task_work_id Taskwork identifier (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskWorkV2GetProfileSchemaForTaskWorkStandardDocumentOperationRequest($task_work_id, $task_work_document_operation_id)
    {
        // verify the required parameter 'task_work_id' is set
        if ($task_work_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_work_id when calling taskWorkV2GetProfileSchemaForTaskWorkStandardDocumentOperation'
            );
        }
        // verify the required parameter 'task_work_document_operation_id' is set
        if ($task_work_document_operation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_work_document_operation_id when calling taskWorkV2GetProfileSchemaForTaskWorkStandardDocumentOperation'
            );
        }

        $resourcePath = '/api/v2/TaskWork/{taskWorkId}/documentsoperations/{taskWorkDocumentOperationId}/standardprofileSchema';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_work_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskWorkId' . '}',
                ObjectSerializer::toPathValue($task_work_id),
                $resourcePath
            );
        }
        // path params
        if ($task_work_document_operation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskWorkDocumentOperationId' . '}',
                ObjectSerializer::toPathValue($task_work_document_operation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskWorkV2GetTaskWorkById
     *
     * This call returns the task
     *
     * @param  int $task_work_id Taskwork identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TaskWorkDTO
     */
    public function taskWorkV2GetTaskWorkById($task_work_id)
    {
        list($response) = $this->taskWorkV2GetTaskWorkByIdWithHttpInfo($task_work_id);
        return $response;
    }

    /**
     * Operation taskWorkV2GetTaskWorkByIdWithHttpInfo
     *
     * This call returns the task
     *
     * @param  int $task_work_id Taskwork identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TaskWorkDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskWorkV2GetTaskWorkByIdWithHttpInfo($task_work_id)
    {
        $returnType = '\Swagger\Client\Model\TaskWorkDTO';
        $request = $this->taskWorkV2GetTaskWorkByIdRequest($task_work_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TaskWorkDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskWorkV2GetTaskWorkByIdAsync
     *
     * This call returns the task
     *
     * @param  int $task_work_id Taskwork identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2GetTaskWorkByIdAsync($task_work_id)
    {
        return $this->taskWorkV2GetTaskWorkByIdAsyncWithHttpInfo($task_work_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskWorkV2GetTaskWorkByIdAsyncWithHttpInfo
     *
     * This call returns the task
     *
     * @param  int $task_work_id Taskwork identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2GetTaskWorkByIdAsyncWithHttpInfo($task_work_id)
    {
        $returnType = '\Swagger\Client\Model\TaskWorkDTO';
        $request = $this->taskWorkV2GetTaskWorkByIdRequest($task_work_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskWorkV2GetTaskWorkById'
     *
     * @param  int $task_work_id Taskwork identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskWorkV2GetTaskWorkByIdRequest($task_work_id)
    {
        // verify the required parameter 'task_work_id' is set
        if ($task_work_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_work_id when calling taskWorkV2GetTaskWorkById'
            );
        }

        $resourcePath = '/api/v2/TaskWork/{taskWorkId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_work_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskWorkId' . '}',
                ObjectSerializer::toPathValue($task_work_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskWorkV2GetTaskWorkForAutoAssign
     *
     * This call returns all autoassigned taskwork associated with a document
     *
     * @param  int $docnumber Document identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TaskWorkDTO[]
     */
    public function taskWorkV2GetTaskWorkForAutoAssign($docnumber)
    {
        list($response) = $this->taskWorkV2GetTaskWorkForAutoAssignWithHttpInfo($docnumber);
        return $response;
    }

    /**
     * Operation taskWorkV2GetTaskWorkForAutoAssignWithHttpInfo
     *
     * This call returns all autoassigned taskwork associated with a document
     *
     * @param  int $docnumber Document identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TaskWorkDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function taskWorkV2GetTaskWorkForAutoAssignWithHttpInfo($docnumber)
    {
        $returnType = '\Swagger\Client\Model\TaskWorkDTO[]';
        $request = $this->taskWorkV2GetTaskWorkForAutoAssignRequest($docnumber);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TaskWorkDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskWorkV2GetTaskWorkForAutoAssignAsync
     *
     * This call returns all autoassigned taskwork associated with a document
     *
     * @param  int $docnumber Document identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2GetTaskWorkForAutoAssignAsync($docnumber)
    {
        return $this->taskWorkV2GetTaskWorkForAutoAssignAsyncWithHttpInfo($docnumber)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskWorkV2GetTaskWorkForAutoAssignAsyncWithHttpInfo
     *
     * This call returns all autoassigned taskwork associated with a document
     *
     * @param  int $docnumber Document identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2GetTaskWorkForAutoAssignAsyncWithHttpInfo($docnumber)
    {
        $returnType = '\Swagger\Client\Model\TaskWorkDTO[]';
        $request = $this->taskWorkV2GetTaskWorkForAutoAssignRequest($docnumber);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskWorkV2GetTaskWorkForAutoAssign'
     *
     * @param  int $docnumber Document identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskWorkV2GetTaskWorkForAutoAssignRequest($docnumber)
    {
        // verify the required parameter 'docnumber' is set
        if ($docnumber === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $docnumber when calling taskWorkV2GetTaskWorkForAutoAssign'
            );
        }

        $resourcePath = '/api/v2/TaskWork/autoassignlist/{docnumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($docnumber !== null) {
            $resourcePath = str_replace(
                '{' . 'docnumber' . '}',
                ObjectSerializer::toPathValue($docnumber),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskWorkV2GetTasks
     *
     * This call executes a task search and return taskwork active for the user and the given workflows ids (with all revisions).  This call could not be compatible with some programming language, in this case use the call api/TaskWork
     *
     * @param  \Swagger\Client\Model\TaskWorkRequestDTO $request The request object that defines select parte and workflows ids, if workflows ids is null or empty returns all taskWork for the user (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function taskWorkV2GetTasks($request)
    {
        list($response) = $this->taskWorkV2GetTasksWithHttpInfo($request);
        return $response;
    }

    /**
     * Operation taskWorkV2GetTasksWithHttpInfo
     *
     * This call executes a task search and return taskwork active for the user and the given workflows ids (with all revisions).  This call could not be compatible with some programming language, in this case use the call api/TaskWork
     *
     * @param  \Swagger\Client\Model\TaskWorkRequestDTO $request The request object that defines select parte and workflows ids, if workflows ids is null or empty returns all taskWork for the user (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskWorkV2GetTasksWithHttpInfo($request)
    {
        $returnType = 'object';
        $request = $this->taskWorkV2GetTasksRequest($request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskWorkV2GetTasksAsync
     *
     * This call executes a task search and return taskwork active for the user and the given workflows ids (with all revisions).  This call could not be compatible with some programming language, in this case use the call api/TaskWork
     *
     * @param  \Swagger\Client\Model\TaskWorkRequestDTO $request The request object that defines select parte and workflows ids, if workflows ids is null or empty returns all taskWork for the user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2GetTasksAsync($request)
    {
        return $this->taskWorkV2GetTasksAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskWorkV2GetTasksAsyncWithHttpInfo
     *
     * This call executes a task search and return taskwork active for the user and the given workflows ids (with all revisions).  This call could not be compatible with some programming language, in this case use the call api/TaskWork
     *
     * @param  \Swagger\Client\Model\TaskWorkRequestDTO $request The request object that defines select parte and workflows ids, if workflows ids is null or empty returns all taskWork for the user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2GetTasksAsyncWithHttpInfo($request)
    {
        $returnType = 'object';
        $request = $this->taskWorkV2GetTasksRequest($request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskWorkV2GetTasks'
     *
     * @param  \Swagger\Client\Model\TaskWorkRequestDTO $request The request object that defines select parte and workflows ids, if workflows ids is null or empty returns all taskWork for the user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskWorkV2GetTasksRequest($request)
    {
        // verify the required parameter 'request' is set
        if ($request === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request when calling taskWorkV2GetTasks'
            );
        }

        $resourcePath = '/api/v2/TaskWork';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskWorkV2ReassignTaskById
     *
     * This call reassigns a task to selected users
     *
     * @param  int $taskworkid Taskwork identifier (required)
     * @param  \Swagger\Client\Model\TaskWorkReassignRequest $reassign_request Information for re assign operation request (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function taskWorkV2ReassignTaskById($taskworkid, $reassign_request)
    {
        $this->taskWorkV2ReassignTaskByIdWithHttpInfo($taskworkid, $reassign_request);
    }

    /**
     * Operation taskWorkV2ReassignTaskByIdWithHttpInfo
     *
     * This call reassigns a task to selected users
     *
     * @param  int $taskworkid Taskwork identifier (required)
     * @param  \Swagger\Client\Model\TaskWorkReassignRequest $reassign_request Information for re assign operation request (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskWorkV2ReassignTaskByIdWithHttpInfo($taskworkid, $reassign_request)
    {
        $returnType = '';
        $request = $this->taskWorkV2ReassignTaskByIdRequest($taskworkid, $reassign_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation taskWorkV2ReassignTaskByIdAsync
     *
     * This call reassigns a task to selected users
     *
     * @param  int $taskworkid Taskwork identifier (required)
     * @param  \Swagger\Client\Model\TaskWorkReassignRequest $reassign_request Information for re assign operation request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2ReassignTaskByIdAsync($taskworkid, $reassign_request)
    {
        return $this->taskWorkV2ReassignTaskByIdAsyncWithHttpInfo($taskworkid, $reassign_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskWorkV2ReassignTaskByIdAsyncWithHttpInfo
     *
     * This call reassigns a task to selected users
     *
     * @param  int $taskworkid Taskwork identifier (required)
     * @param  \Swagger\Client\Model\TaskWorkReassignRequest $reassign_request Information for re assign operation request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2ReassignTaskByIdAsyncWithHttpInfo($taskworkid, $reassign_request)
    {
        $returnType = '';
        $request = $this->taskWorkV2ReassignTaskByIdRequest($taskworkid, $reassign_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskWorkV2ReassignTaskById'
     *
     * @param  int $taskworkid Taskwork identifier (required)
     * @param  \Swagger\Client\Model\TaskWorkReassignRequest $reassign_request Information for re assign operation request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskWorkV2ReassignTaskByIdRequest($taskworkid, $reassign_request)
    {
        // verify the required parameter 'taskworkid' is set
        if ($taskworkid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $taskworkid when calling taskWorkV2ReassignTaskById'
            );
        }
        // verify the required parameter 'reassign_request' is set
        if ($reassign_request === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reassign_request when calling taskWorkV2ReassignTaskById'
            );
        }

        $resourcePath = '/api/v2/TaskWork/reassign/{taskworkid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($taskworkid !== null) {
            $resourcePath = str_replace(
                '{' . 'taskworkid' . '}',
                ObjectSerializer::toPathValue($taskworkid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($reassign_request)) {
            $_tempBody = $reassign_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskWorkV2ReassignUsersTaskById
     *
     * This call reassigns a task to selected users
     *
     * @param  int $taskworkid Taskwork identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\UserCompleteDTO[]
     */
    public function taskWorkV2ReassignUsersTaskById($taskworkid)
    {
        list($response) = $this->taskWorkV2ReassignUsersTaskByIdWithHttpInfo($taskworkid);
        return $response;
    }

    /**
     * Operation taskWorkV2ReassignUsersTaskByIdWithHttpInfo
     *
     * This call reassigns a task to selected users
     *
     * @param  int $taskworkid Taskwork identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\UserCompleteDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function taskWorkV2ReassignUsersTaskByIdWithHttpInfo($taskworkid)
    {
        $returnType = '\Swagger\Client\Model\UserCompleteDTO[]';
        $request = $this->taskWorkV2ReassignUsersTaskByIdRequest($taskworkid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\UserCompleteDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskWorkV2ReassignUsersTaskByIdAsync
     *
     * This call reassigns a task to selected users
     *
     * @param  int $taskworkid Taskwork identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2ReassignUsersTaskByIdAsync($taskworkid)
    {
        return $this->taskWorkV2ReassignUsersTaskByIdAsyncWithHttpInfo($taskworkid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskWorkV2ReassignUsersTaskByIdAsyncWithHttpInfo
     *
     * This call reassigns a task to selected users
     *
     * @param  int $taskworkid Taskwork identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2ReassignUsersTaskByIdAsyncWithHttpInfo($taskworkid)
    {
        $returnType = '\Swagger\Client\Model\UserCompleteDTO[]';
        $request = $this->taskWorkV2ReassignUsersTaskByIdRequest($taskworkid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskWorkV2ReassignUsersTaskById'
     *
     * @param  int $taskworkid Taskwork identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskWorkV2ReassignUsersTaskByIdRequest($taskworkid)
    {
        // verify the required parameter 'taskworkid' is set
        if ($taskworkid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $taskworkid when calling taskWorkV2ReassignUsersTaskById'
            );
        }

        $resourcePath = '/api/v2/TaskWork/reassignusers/{taskworkid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($taskworkid !== null) {
            $resourcePath = str_replace(
                '{' . 'taskworkid' . '}',
                ObjectSerializer::toPathValue($taskworkid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskWorkV2SetProfileForTaskWorkBySelectionDocumentOperation
     *
     * This call adds a profile to process for a selection document taskwork operation
     *
     * @param  int $task_work_id Taskwork identifie (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     * @param  int[] $docnumbers List of document identifier to add (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function taskWorkV2SetProfileForTaskWorkBySelectionDocumentOperation($task_work_id, $task_work_document_operation_id, $docnumbers)
    {
        $this->taskWorkV2SetProfileForTaskWorkBySelectionDocumentOperationWithHttpInfo($task_work_id, $task_work_document_operation_id, $docnumbers);
    }

    /**
     * Operation taskWorkV2SetProfileForTaskWorkBySelectionDocumentOperationWithHttpInfo
     *
     * This call adds a profile to process for a selection document taskwork operation
     *
     * @param  int $task_work_id Taskwork identifie (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     * @param  int[] $docnumbers List of document identifier to add (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskWorkV2SetProfileForTaskWorkBySelectionDocumentOperationWithHttpInfo($task_work_id, $task_work_document_operation_id, $docnumbers)
    {
        $returnType = '';
        $request = $this->taskWorkV2SetProfileForTaskWorkBySelectionDocumentOperationRequest($task_work_id, $task_work_document_operation_id, $docnumbers);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation taskWorkV2SetProfileForTaskWorkBySelectionDocumentOperationAsync
     *
     * This call adds a profile to process for a selection document taskwork operation
     *
     * @param  int $task_work_id Taskwork identifie (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     * @param  int[] $docnumbers List of document identifier to add (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2SetProfileForTaskWorkBySelectionDocumentOperationAsync($task_work_id, $task_work_document_operation_id, $docnumbers)
    {
        return $this->taskWorkV2SetProfileForTaskWorkBySelectionDocumentOperationAsyncWithHttpInfo($task_work_id, $task_work_document_operation_id, $docnumbers)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskWorkV2SetProfileForTaskWorkBySelectionDocumentOperationAsyncWithHttpInfo
     *
     * This call adds a profile to process for a selection document taskwork operation
     *
     * @param  int $task_work_id Taskwork identifie (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     * @param  int[] $docnumbers List of document identifier to add (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2SetProfileForTaskWorkBySelectionDocumentOperationAsyncWithHttpInfo($task_work_id, $task_work_document_operation_id, $docnumbers)
    {
        $returnType = '';
        $request = $this->taskWorkV2SetProfileForTaskWorkBySelectionDocumentOperationRequest($task_work_id, $task_work_document_operation_id, $docnumbers);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskWorkV2SetProfileForTaskWorkBySelectionDocumentOperation'
     *
     * @param  int $task_work_id Taskwork identifie (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     * @param  int[] $docnumbers List of document identifier to add (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskWorkV2SetProfileForTaskWorkBySelectionDocumentOperationRequest($task_work_id, $task_work_document_operation_id, $docnumbers)
    {
        // verify the required parameter 'task_work_id' is set
        if ($task_work_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_work_id when calling taskWorkV2SetProfileForTaskWorkBySelectionDocumentOperation'
            );
        }
        // verify the required parameter 'task_work_document_operation_id' is set
        if ($task_work_document_operation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_work_document_operation_id when calling taskWorkV2SetProfileForTaskWorkBySelectionDocumentOperation'
            );
        }
        // verify the required parameter 'docnumbers' is set
        if ($docnumbers === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $docnumbers when calling taskWorkV2SetProfileForTaskWorkBySelectionDocumentOperation'
            );
        }

        $resourcePath = '/api/v2/TaskWork/{taskWorkId}/documentsoperations/{taskWorkDocumentOperationId}/byselection';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_work_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskWorkId' . '}',
                ObjectSerializer::toPathValue($task_work_id),
                $resourcePath
            );
        }
        // path params
        if ($task_work_document_operation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskWorkDocumentOperationId' . '}',
                ObjectSerializer::toPathValue($task_work_document_operation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($docnumbers)) {
            $_tempBody = $docnumbers;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskWorkV2SetProfileForTaskWorkMaskDocumentOperation
     *
     * This call profiles a new document for a mask insert document taskwork operation
     *
     * @param  int $task_work_id Taskwork identifie (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     * @param  \Swagger\Client\Model\ProfileDTO $profile profile (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ProfileResultDTO
     */
    public function taskWorkV2SetProfileForTaskWorkMaskDocumentOperation($task_work_id, $task_work_document_operation_id, $profile = null)
    {
        list($response) = $this->taskWorkV2SetProfileForTaskWorkMaskDocumentOperationWithHttpInfo($task_work_id, $task_work_document_operation_id, $profile);
        return $response;
    }

    /**
     * Operation taskWorkV2SetProfileForTaskWorkMaskDocumentOperationWithHttpInfo
     *
     * This call profiles a new document for a mask insert document taskwork operation
     *
     * @param  int $task_work_id Taskwork identifie (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     * @param  \Swagger\Client\Model\ProfileDTO $profile (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ProfileResultDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskWorkV2SetProfileForTaskWorkMaskDocumentOperationWithHttpInfo($task_work_id, $task_work_document_operation_id, $profile = null)
    {
        $returnType = '\Swagger\Client\Model\ProfileResultDTO';
        $request = $this->taskWorkV2SetProfileForTaskWorkMaskDocumentOperationRequest($task_work_id, $task_work_document_operation_id, $profile);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ProfileResultDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskWorkV2SetProfileForTaskWorkMaskDocumentOperationAsync
     *
     * This call profiles a new document for a mask insert document taskwork operation
     *
     * @param  int $task_work_id Taskwork identifie (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     * @param  \Swagger\Client\Model\ProfileDTO $profile (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2SetProfileForTaskWorkMaskDocumentOperationAsync($task_work_id, $task_work_document_operation_id, $profile = null)
    {
        return $this->taskWorkV2SetProfileForTaskWorkMaskDocumentOperationAsyncWithHttpInfo($task_work_id, $task_work_document_operation_id, $profile)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskWorkV2SetProfileForTaskWorkMaskDocumentOperationAsyncWithHttpInfo
     *
     * This call profiles a new document for a mask insert document taskwork operation
     *
     * @param  int $task_work_id Taskwork identifie (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     * @param  \Swagger\Client\Model\ProfileDTO $profile (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2SetProfileForTaskWorkMaskDocumentOperationAsyncWithHttpInfo($task_work_id, $task_work_document_operation_id, $profile = null)
    {
        $returnType = '\Swagger\Client\Model\ProfileResultDTO';
        $request = $this->taskWorkV2SetProfileForTaskWorkMaskDocumentOperationRequest($task_work_id, $task_work_document_operation_id, $profile);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskWorkV2SetProfileForTaskWorkMaskDocumentOperation'
     *
     * @param  int $task_work_id Taskwork identifie (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     * @param  \Swagger\Client\Model\ProfileDTO $profile (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskWorkV2SetProfileForTaskWorkMaskDocumentOperationRequest($task_work_id, $task_work_document_operation_id, $profile = null)
    {
        // verify the required parameter 'task_work_id' is set
        if ($task_work_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_work_id when calling taskWorkV2SetProfileForTaskWorkMaskDocumentOperation'
            );
        }
        // verify the required parameter 'task_work_document_operation_id' is set
        if ($task_work_document_operation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_work_document_operation_id when calling taskWorkV2SetProfileForTaskWorkMaskDocumentOperation'
            );
        }

        $resourcePath = '/api/v2/TaskWork/{taskWorkId}/documentsoperations/{taskWorkDocumentOperationId}/bymask';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_work_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskWorkId' . '}',
                ObjectSerializer::toPathValue($task_work_id),
                $resourcePath
            );
        }
        // path params
        if ($task_work_document_operation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskWorkDocumentOperationId' . '}',
                ObjectSerializer::toPathValue($task_work_document_operation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($profile)) {
            $_tempBody = $profile;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskWorkV2SetProfileForTaskWorkModelDocumentOperation
     *
     * This call profiles a new document for a model insert document taskwork operation
     *
     * @param  int $task_work_id Taskwork identifie (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     * @param  \Swagger\Client\Model\ProfileDTO $profile profile (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ProfileResultDTO
     */
    public function taskWorkV2SetProfileForTaskWorkModelDocumentOperation($task_work_id, $task_work_document_operation_id, $profile = null)
    {
        list($response) = $this->taskWorkV2SetProfileForTaskWorkModelDocumentOperationWithHttpInfo($task_work_id, $task_work_document_operation_id, $profile);
        return $response;
    }

    /**
     * Operation taskWorkV2SetProfileForTaskWorkModelDocumentOperationWithHttpInfo
     *
     * This call profiles a new document for a model insert document taskwork operation
     *
     * @param  int $task_work_id Taskwork identifie (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     * @param  \Swagger\Client\Model\ProfileDTO $profile (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ProfileResultDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskWorkV2SetProfileForTaskWorkModelDocumentOperationWithHttpInfo($task_work_id, $task_work_document_operation_id, $profile = null)
    {
        $returnType = '\Swagger\Client\Model\ProfileResultDTO';
        $request = $this->taskWorkV2SetProfileForTaskWorkModelDocumentOperationRequest($task_work_id, $task_work_document_operation_id, $profile);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ProfileResultDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskWorkV2SetProfileForTaskWorkModelDocumentOperationAsync
     *
     * This call profiles a new document for a model insert document taskwork operation
     *
     * @param  int $task_work_id Taskwork identifie (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     * @param  \Swagger\Client\Model\ProfileDTO $profile (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2SetProfileForTaskWorkModelDocumentOperationAsync($task_work_id, $task_work_document_operation_id, $profile = null)
    {
        return $this->taskWorkV2SetProfileForTaskWorkModelDocumentOperationAsyncWithHttpInfo($task_work_id, $task_work_document_operation_id, $profile)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskWorkV2SetProfileForTaskWorkModelDocumentOperationAsyncWithHttpInfo
     *
     * This call profiles a new document for a model insert document taskwork operation
     *
     * @param  int $task_work_id Taskwork identifie (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     * @param  \Swagger\Client\Model\ProfileDTO $profile (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2SetProfileForTaskWorkModelDocumentOperationAsyncWithHttpInfo($task_work_id, $task_work_document_operation_id, $profile = null)
    {
        $returnType = '\Swagger\Client\Model\ProfileResultDTO';
        $request = $this->taskWorkV2SetProfileForTaskWorkModelDocumentOperationRequest($task_work_id, $task_work_document_operation_id, $profile);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskWorkV2SetProfileForTaskWorkModelDocumentOperation'
     *
     * @param  int $task_work_id Taskwork identifie (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     * @param  \Swagger\Client\Model\ProfileDTO $profile (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskWorkV2SetProfileForTaskWorkModelDocumentOperationRequest($task_work_id, $task_work_document_operation_id, $profile = null)
    {
        // verify the required parameter 'task_work_id' is set
        if ($task_work_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_work_id when calling taskWorkV2SetProfileForTaskWorkModelDocumentOperation'
            );
        }
        // verify the required parameter 'task_work_document_operation_id' is set
        if ($task_work_document_operation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_work_document_operation_id when calling taskWorkV2SetProfileForTaskWorkModelDocumentOperation'
            );
        }

        $resourcePath = '/api/v2/TaskWork/{taskWorkId}/documentsoperations/{taskWorkDocumentOperationId}/bymodel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_work_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskWorkId' . '}',
                ObjectSerializer::toPathValue($task_work_id),
                $resourcePath
            );
        }
        // path params
        if ($task_work_document_operation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskWorkDocumentOperationId' . '}',
                ObjectSerializer::toPathValue($task_work_document_operation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($profile)) {
            $_tempBody = $profile;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskWorkV2SetProfileForTaskWorkStandardDocumentOperation
     *
     * This call profiles a new document for a standard insert document taskwork operation
     *
     * @param  int $task_work_id Taskwork identifie (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     * @param  \Swagger\Client\Model\ProfileDTO $profile profile (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ProfileResultDTO
     */
    public function taskWorkV2SetProfileForTaskWorkStandardDocumentOperation($task_work_id, $task_work_document_operation_id, $profile = null)
    {
        list($response) = $this->taskWorkV2SetProfileForTaskWorkStandardDocumentOperationWithHttpInfo($task_work_id, $task_work_document_operation_id, $profile);
        return $response;
    }

    /**
     * Operation taskWorkV2SetProfileForTaskWorkStandardDocumentOperationWithHttpInfo
     *
     * This call profiles a new document for a standard insert document taskwork operation
     *
     * @param  int $task_work_id Taskwork identifie (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     * @param  \Swagger\Client\Model\ProfileDTO $profile (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ProfileResultDTO, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskWorkV2SetProfileForTaskWorkStandardDocumentOperationWithHttpInfo($task_work_id, $task_work_document_operation_id, $profile = null)
    {
        $returnType = '\Swagger\Client\Model\ProfileResultDTO';
        $request = $this->taskWorkV2SetProfileForTaskWorkStandardDocumentOperationRequest($task_work_id, $task_work_document_operation_id, $profile);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ProfileResultDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskWorkV2SetProfileForTaskWorkStandardDocumentOperationAsync
     *
     * This call profiles a new document for a standard insert document taskwork operation
     *
     * @param  int $task_work_id Taskwork identifie (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     * @param  \Swagger\Client\Model\ProfileDTO $profile (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2SetProfileForTaskWorkStandardDocumentOperationAsync($task_work_id, $task_work_document_operation_id, $profile = null)
    {
        return $this->taskWorkV2SetProfileForTaskWorkStandardDocumentOperationAsyncWithHttpInfo($task_work_id, $task_work_document_operation_id, $profile)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskWorkV2SetProfileForTaskWorkStandardDocumentOperationAsyncWithHttpInfo
     *
     * This call profiles a new document for a standard insert document taskwork operation
     *
     * @param  int $task_work_id Taskwork identifie (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     * @param  \Swagger\Client\Model\ProfileDTO $profile (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2SetProfileForTaskWorkStandardDocumentOperationAsyncWithHttpInfo($task_work_id, $task_work_document_operation_id, $profile = null)
    {
        $returnType = '\Swagger\Client\Model\ProfileResultDTO';
        $request = $this->taskWorkV2SetProfileForTaskWorkStandardDocumentOperationRequest($task_work_id, $task_work_document_operation_id, $profile);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskWorkV2SetProfileForTaskWorkStandardDocumentOperation'
     *
     * @param  int $task_work_id Taskwork identifie (required)
     * @param  string $task_work_document_operation_id Id of the operation (required)
     * @param  \Swagger\Client\Model\ProfileDTO $profile (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskWorkV2SetProfileForTaskWorkStandardDocumentOperationRequest($task_work_id, $task_work_document_operation_id, $profile = null)
    {
        // verify the required parameter 'task_work_id' is set
        if ($task_work_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_work_id when calling taskWorkV2SetProfileForTaskWorkStandardDocumentOperation'
            );
        }
        // verify the required parameter 'task_work_document_operation_id' is set
        if ($task_work_document_operation_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_work_document_operation_id when calling taskWorkV2SetProfileForTaskWorkStandardDocumentOperation'
            );
        }

        $resourcePath = '/api/v2/TaskWork/{taskWorkId}/documentsoperations/{taskWorkDocumentOperationId}/bystandard';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_work_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskWorkId' . '}',
                ObjectSerializer::toPathValue($task_work_id),
                $resourcePath
            );
        }
        // path params
        if ($task_work_document_operation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskWorkDocumentOperationId' . '}',
                ObjectSerializer::toPathValue($task_work_document_operation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($profile)) {
            $_tempBody = $profile;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskWorkV2SetTaskPriority
     *
     * This call sets the tasks priority
     *
     * @param  int[] $task_ids List of task identifier (required)
     * @param  int $priority Priority (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function taskWorkV2SetTaskPriority($task_ids, $priority)
    {
        list($response) = $this->taskWorkV2SetTaskPriorityWithHttpInfo($task_ids, $priority);
        return $response;
    }

    /**
     * Operation taskWorkV2SetTaskPriorityWithHttpInfo
     *
     * This call sets the tasks priority
     *
     * @param  int[] $task_ids List of task identifier (required)
     * @param  int $priority Priority (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskWorkV2SetTaskPriorityWithHttpInfo($task_ids, $priority)
    {
        $returnType = 'int';
        $request = $this->taskWorkV2SetTaskPriorityRequest($task_ids, $priority);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskWorkV2SetTaskPriorityAsync
     *
     * This call sets the tasks priority
     *
     * @param  int[] $task_ids List of task identifier (required)
     * @param  int $priority Priority (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2SetTaskPriorityAsync($task_ids, $priority)
    {
        return $this->taskWorkV2SetTaskPriorityAsyncWithHttpInfo($task_ids, $priority)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskWorkV2SetTaskPriorityAsyncWithHttpInfo
     *
     * This call sets the tasks priority
     *
     * @param  int[] $task_ids List of task identifier (required)
     * @param  int $priority Priority (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2SetTaskPriorityAsyncWithHttpInfo($task_ids, $priority)
    {
        $returnType = 'int';
        $request = $this->taskWorkV2SetTaskPriorityRequest($task_ids, $priority);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskWorkV2SetTaskPriority'
     *
     * @param  int[] $task_ids List of task identifier (required)
     * @param  int $priority Priority (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskWorkV2SetTaskPriorityRequest($task_ids, $priority)
    {
        // verify the required parameter 'task_ids' is set
        if ($task_ids === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_ids when calling taskWorkV2SetTaskPriority'
            );
        }
        // verify the required parameter 'priority' is set
        if ($priority === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $priority when calling taskWorkV2SetTaskPriority'
            );
        }

        $resourcePath = '/api/v2/TaskWork/priority/{priority}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($priority !== null) {
            $resourcePath = str_replace(
                '{' . 'priority' . '}',
                ObjectSerializer::toPathValue($priority),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($task_ids)) {
            $_tempBody = $task_ids;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskWorkV2SetTaskRead
     *
     * This call sets the task as read
     *
     * @param  int[] $taskid Task Identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function taskWorkV2SetTaskRead($taskid)
    {
        list($response) = $this->taskWorkV2SetTaskReadWithHttpInfo($taskid);
        return $response;
    }

    /**
     * Operation taskWorkV2SetTaskReadWithHttpInfo
     *
     * This call sets the task as read
     *
     * @param  int[] $taskid Task Identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskWorkV2SetTaskReadWithHttpInfo($taskid)
    {
        $returnType = 'int';
        $request = $this->taskWorkV2SetTaskReadRequest($taskid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskWorkV2SetTaskReadAsync
     *
     * This call sets the task as read
     *
     * @param  int[] $taskid Task Identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2SetTaskReadAsync($taskid)
    {
        return $this->taskWorkV2SetTaskReadAsyncWithHttpInfo($taskid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskWorkV2SetTaskReadAsyncWithHttpInfo
     *
     * This call sets the task as read
     *
     * @param  int[] $taskid Task Identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2SetTaskReadAsyncWithHttpInfo($taskid)
    {
        $returnType = 'int';
        $request = $this->taskWorkV2SetTaskReadRequest($taskid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskWorkV2SetTaskRead'
     *
     * @param  int[] $taskid Task Identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskWorkV2SetTaskReadRequest($taskid)
    {
        // verify the required parameter 'taskid' is set
        if ($taskid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $taskid when calling taskWorkV2SetTaskRead'
            );
        }

        $resourcePath = '/api/v2/TaskWork/read';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($taskid)) {
            $_tempBody = $taskid;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskWorkV2SetTaskUnRead
     *
     * This call sets the tasks as unread
     *
     * @param  int[] $task_ids List of task identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function taskWorkV2SetTaskUnRead($task_ids)
    {
        list($response) = $this->taskWorkV2SetTaskUnReadWithHttpInfo($task_ids);
        return $response;
    }

    /**
     * Operation taskWorkV2SetTaskUnReadWithHttpInfo
     *
     * This call sets the tasks as unread
     *
     * @param  int[] $task_ids List of task identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskWorkV2SetTaskUnReadWithHttpInfo($task_ids)
    {
        $returnType = 'int';
        $request = $this->taskWorkV2SetTaskUnReadRequest($task_ids);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation taskWorkV2SetTaskUnReadAsync
     *
     * This call sets the tasks as unread
     *
     * @param  int[] $task_ids List of task identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2SetTaskUnReadAsync($task_ids)
    {
        return $this->taskWorkV2SetTaskUnReadAsyncWithHttpInfo($task_ids)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskWorkV2SetTaskUnReadAsyncWithHttpInfo
     *
     * This call sets the tasks as unread
     *
     * @param  int[] $task_ids List of task identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2SetTaskUnReadAsyncWithHttpInfo($task_ids)
    {
        $returnType = 'int';
        $request = $this->taskWorkV2SetTaskUnReadRequest($task_ids);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskWorkV2SetTaskUnRead'
     *
     * @param  int[] $task_ids List of task identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskWorkV2SetTaskUnReadRequest($task_ids)
    {
        // verify the required parameter 'task_ids' is set
        if ($task_ids === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_ids when calling taskWorkV2SetTaskUnRead'
            );
        }

        $resourcePath = '/api/v2/TaskWork/unread';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($task_ids)) {
            $_tempBody = $task_ids;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taskWorkV2TaskWorkTakeCharge
     *
     * This call takes charge of a taskwork
     *
     * @param  int $task_work_id Taskwork identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function taskWorkV2TaskWorkTakeCharge($task_work_id)
    {
        $this->taskWorkV2TaskWorkTakeChargeWithHttpInfo($task_work_id);
    }

    /**
     * Operation taskWorkV2TaskWorkTakeChargeWithHttpInfo
     *
     * This call takes charge of a taskwork
     *
     * @param  int $task_work_id Taskwork identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function taskWorkV2TaskWorkTakeChargeWithHttpInfo($task_work_id)
    {
        $returnType = '';
        $request = $this->taskWorkV2TaskWorkTakeChargeRequest($task_work_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation taskWorkV2TaskWorkTakeChargeAsync
     *
     * This call takes charge of a taskwork
     *
     * @param  int $task_work_id Taskwork identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2TaskWorkTakeChargeAsync($task_work_id)
    {
        return $this->taskWorkV2TaskWorkTakeChargeAsyncWithHttpInfo($task_work_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taskWorkV2TaskWorkTakeChargeAsyncWithHttpInfo
     *
     * This call takes charge of a taskwork
     *
     * @param  int $task_work_id Taskwork identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taskWorkV2TaskWorkTakeChargeAsyncWithHttpInfo($task_work_id)
    {
        $returnType = '';
        $request = $this->taskWorkV2TaskWorkTakeChargeRequest($task_work_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taskWorkV2TaskWorkTakeCharge'
     *
     * @param  int $task_work_id Taskwork identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taskWorkV2TaskWorkTakeChargeRequest($task_work_id)
    {
        // verify the required parameter 'task_work_id' is set
        if ($task_work_id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_work_id when calling taskWorkV2TaskWorkTakeCharge'
            );
        }

        $resourcePath = '/api/v2/TaskWork/{taskWorkId}/TakeCharge';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($task_work_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskWorkId' . '}',
                ObjectSerializer::toPathValue($task_work_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
